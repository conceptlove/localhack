export { produce } from "immer";
export const identity = h(T, null,
    "(x: T): T => x export const always = ",
    h(T, null,
        "(x: T) => () => x export const tap = ",
        h(T, null),
        " R extends any[] = []>( fn: (x: T, ...rest: R) => void, ) => (x: T, ...rest: R) => (fn(x, ...rest), x) export const each = ",
        h(T, null,
            "(fn: (x: T) => void) => tap",
            h(T, null),
            "]>(xs => xs.forEach(fn)) export const set = ",
            h(S, null,
                "(partial: Partial",
                h(S, null,
                    "): Transform",
                    h(S, null,
                        " => state => ",
                    ,
                        "const res = partial as S const out = ",
                        " as S for (const k in state) ",
                        out[k] = k in res ? res[k] : state[k],
                        "return out } export function clone",
                        h(T, { extends: true, object: true }),
                        " any[]>(v: T): T ",
                    ,
                        "if (Array.isArray(v)) ",
                    ,
                        "return [...v] as T } else ",
                    ,
                        "return ",
                        v,
                        "} } export type KeyMap",
                        h(T, null,
                            " = ",
                            [K in keyof, T],
                            ": (v: T[K]) => T[K] } export const edit = ",
                            h(S, null,
                                "( editFn: (state: S) => Partial",
                                h(S, null,
                                    ", ): Transform",
                                    h(S, null,
                                        " => state => set",
                                        h(S, null,
                                            "(editFn(state))(state) export const mut = ",
                                            h(T, { extends: true, object: true }),
                                            " any[]>(mutFn: (item: T) => void) => ( item: T, ) => tap(mutFn)(clone(item)) export const map = ",
                                            h(T, null),
                                            " S extends T>(mapFns: KeyMap",
                                            h(T, null,
                                                "): Transform",
                                                h(S, null,
                                                    " => edit(state => ",
                                                    let,
                                                    " changes = ",
                                                    " as T for (const k in mapFns) ",
                                                    changes[k] = mapFns[k](state[k]),
                                                    "return changes }) export type Obj",
                                                    h(T, null,
                                                        " = ",
                                                        [key],
                                                        ": string]: T } export const mapValues = ",
                                                        h(T, null),
                                                        " V>(entryFn: (val: T, key: string) => V) => ( obj: Obj",
                                                        h(T, null,
                                                            ", ): Obj",
                                                            h(V, null,
                                                                " => ",
                                                            ,
                                                                "const out = ",
                                                                " as Obj",
                                                                h(V, null,
                                                                    "for (const k in obj) ",
                                                                    out[k] = entryFn(obj[k], k),
                                                                    "return out } export const makeObj = ",
                                                                    h(T, null),
                                                                    " V>( items: T[], fn: (item: T) => [string, V], ): Obj",
                                                                    h(V, null,
                                                                        " => Object.fromEntries(items.map(fn)) export const mapWhen = ",
                                                                        h(T, null,
                                                                            "(pred: (item: T) => boolean, fn: (item: T) => T) => ( items: T[], ): T[] => items.map(item => (pred(item) ? fn(item) : item)) export const apply = ",
                                                                            h(T, null,
                                                                                "(v: T, applyFn?: (v: T) => T) => applyFn?.(v) ?? v export const toggle = (v: boolean) => !v export const pipe = ",
                                                                                h(T, null,
                                                                                    "(...pipeFns: (Transform",
                                                                                    h(T, null,
                                                                                        " | undefined)[]) => ( val: T, ): T => pipeFns.reduce(apply, val) export const push = ",
                                                                                        h(T, null,
                                                                                            "(...vals: T[]) => (list: T[]) => [...list, ...vals] export async function tests() ",
                                                                                        ,
                                                                                            "const ", (deepEqual, test),
                                                                                            " = await import(\"./testing.mjs\") type T = ",
                                                                                            a,
                                                                                            ": number; b: number } const init: T = ",
                                                                                            a,
                                                                                            ": 1, b: 2 } test(",
                                                                                            a,
                                                                                            ": 1, b: 2 }).eq(set(",
                                                                                            a,
                                                                                            ": 3 })) deepEqual(set(",
                                                                                            a,
                                                                                            ": 3 })(init), ",
                                                                                            a,
                                                                                            ": 1, b: 2 }) // deepEqual(edit()) deepEqual(push(3, 4)([1, 2]), [1, 2, 3, 4]) }")))))))))))))))))))))));
